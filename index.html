<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Volca Sample Breakbeat Embalmer</title>
<style>
body {
  background: #111;
  font-family: 'Verdana', sans-serif;
  color: #eee;
  display: flex;
  justify-content: center;
  padding: 30px;
}

.volca-panel {
  width: 500px;
  background: linear-gradient(#222, #111);
  border: 4px solid #555;
  border-radius: 15px;
  box-shadow: 0 0 20px #000;
  padding: 20px;
  background-image: 
    linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
  background-size: 10px 10px;
}

.volca-docs {
  width: 350px;
  background: linear-gradient(#222, #111);
  border: 4px solid #555;
  border-radius: 15px;
  box-shadow: 0 0 20px #000;
  margin-left: 20px;
  padding: 20px;
  background-image: 
    linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
  background-size: 10px 10px;
  line-height: 1.5;
}

.volca-docs a:link { color: #f5d76e; }
.volca-docs a:visited { color: red; }

h1 {
  font-family: 'Courier New', monospace;
  color: #f5d76e;
  text-align: center;
  margin-bottom: 20px;
  text-shadow: 0 0 10px #f5d76e;
}

.controls {
  display: flex;
  flex-direction: column;
  gap: 15px;
  margin-bottom: 20px;
}

.control-group {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.control-group label {
  font-size: 14px;
  color: #f5d76e;
}

input[type=file] {
  color: #fff;
}

.readout {
  font-weight: bold;
  color: #0f0;
}

.buttons {
  display: flex;
  justify-content: center;
  margin-top: 20px;
}

button {
  background: linear-gradient(#333, #111);
  color: #fff;
  border-radius: 6px;
  border: 2px solid #555;
  padding: 10px 20px;
  cursor: pointer;
  font-weight: bold;
  box-shadow: 0 3px #000;
  transition: 0.1s;
}

button:hover {
  background: linear-gradient(#444, #222);
}

button:active {
  transform: translateY(2px);
  box-shadow: 0 1px #000;
}
</style>
</head>
<body>

<div class="volca-panel">
  <h1>Volca Sample Breakbeat Embalmer</h1>

  <p>A browser-based tool that automates the procedure described in <a href="https://www.youtube.com/watch?v=ci_ReYDKUfI">Chris Lody's tutorial</a> for prepping breakbeats for sample chopping on the Korg Volca Sample.</p>
  <p>VSBE embalms the dead sounds of yesterday, readying them to be chopped and sequenced into the new sounds of tomorrow.</p>
  <br />

  <div class="controls">
    <div class="control-group">
      <label>Select Audio File:</label>
      <input type="file" id="fileInput" accept="audio/*">
    </div>
    <div class="control-group">
      <label>Original Length (samples):</label>
      <span class="readout" id="origLength">--</span>
    </div>
    <div class="control-group">
      <label>Silence To Be Added (samples):</label>
      <span class="readout" id="silenceLength">--</span>
    </div>
    <div class="control-group">
      <label>New File Length (samples):</label>
      <span class="readout" id="newLength">--</span>
    </div>
  </div>

  <div class="buttons">
    <button id="processBtn">Export WAV</button>
  </div>
</div>

<div class="volca-docs">
  <p>Not running this locally?</br>
<a href="https://github.com/davemh/volca-sample-breakbeat-embalmer/archive/refs/heads/main.zip">Download Volca SBE</a> for offline use.</p>
<p>Read the <a href="https://github.com/davemh/volca-sample-breakbeat-embalmer/blob/main/README.md">full documentation</a>.
<p>Have ideas? <a href="https://github.com/davemh/volca-sample-breakbeat-embalmer/">Contribute</a> to the project.</p>

  <p>How To Use:</p>
  <ol>
    <li>Select an audio file on your local machine.</li>
    <li>Breakbeat Embalmer measures its length in samples.</li>
    <li>Breakbeat Embalmer calculates the amount of silence to be added, based on the standard of <code>original file length Ã— 0.11111</code>.</li>
    <li>It appends that silence to the end of the original audio file and allows you to export the result as a new WAV.</li>
    <li>Transfer the resulting file to your Volca Sample, using your preferred sample transfer utility.</li>
  </ol>
  <p>Runs best in Chrome.</p>
  <p>Brought to you by <a href="https://reverse-engine.com">Reverse Engine Records</a>. Made by <a href="https://davemh.com">a Volca enthusiast</a>, unaffiliated with Korg.</p>
  <p>Method credit to <a href="https://www.youtube.com/chrislodymusic">Chris Lody</a>. Made with appreciation for his contributions to the Korg Volca user community.</p>
</div>

<script>
const fileInput = document.getElementById('fileInput');
const processBtn = document.getElementById('processBtn');
const origLengthEl = document.getElementById('origLength');
const silenceLengthEl = document.getElementById('silenceLength');
const newLengthEl = document.getElementById('newLength');

let currentBuffer = null;

async function decodeAudioFile(file) {
  const arrayBuffer = await file.arrayBuffer();
  const audioCtx = new AudioContext();
  return audioCtx.decodeAudioData(arrayBuffer);
}

fileInput.addEventListener('change', async () => {
  const file = fileInput.files[0];
  if (!file) return;
  const buffer = await decodeAudioFile(file);
  currentBuffer = buffer;
  const length = buffer.length;
  const silenceLength = Math.floor(length * 0.11111);
  const newLength = length + silenceLength;
  origLengthEl.textContent = length.toLocaleString();
  silenceLengthEl.textContent = silenceLength.toLocaleString();
  newLengthEl.textContent = newLength.toLocaleString();
});

processBtn.addEventListener('click', () => {
  if (!currentBuffer) {
    alert("Please select a file first.");
    return;
  }

  const numChannels = currentBuffer.numberOfChannels;
  const sampleRate = currentBuffer.sampleRate;
  const length = currentBuffer.length;
  const silenceLength = Math.floor(length * 0.11111);
  const newLength = length + silenceLength;

  const newBuffer = new AudioBuffer({
    length: newLength,
    numberOfChannels: numChannels,
    sampleRate: sampleRate
  });

  // Copy original audio
  for (let ch = 0; ch < numChannels; ch++) {
    const oldData = currentBuffer.getChannelData(ch);
    const newData = newBuffer.getChannelData(ch);
    newData.set(oldData, 0);
    // rest remains silence
  }

  const wavArrayBuffer = audioBufferToWav(newBuffer);
  const blob = new Blob([wavArrayBuffer], { type: "audio/wav" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "processed.wav";
  a.click();
});

// ==== WAV ENCODER (unchanged) ====
function audioBufferToWav(buffer) {
  const numChannels = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const format = 1; // PCM
  const bitDepth = 16;

  let result;
  if (numChannels === 2) {
    result = interleave(buffer.getChannelData(0), buffer.getChannelData(1));
  } else {
    result = buffer.getChannelData(0);
  }

  return encodeWav(result, numChannels, sampleRate, format, bitDepth);
}

function interleave(left, right) {
  const length = left.length + right.length;
  const result = new Float32Array(length);
  let index = 0, inputIndex = 0;
  while (index < length) {
    result[index++] = left[inputIndex];
    result[index++] = right[inputIndex];
    inputIndex++;
  }
  return result;
}

function encodeWav(samples, numChannels, sampleRate, format, bitDepth) {
  const bytesPerSample = bitDepth / 8;
  const blockAlign = numChannels * bytesPerSample;
  const buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
  const view = new DataView(buffer);

  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + samples.length * bytesPerSample, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, format, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * blockAlign, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitDepth, true);
  writeString(view, 36, 'data');
  view.setUint32(40, samples.length * bytesPerSample, true);

  floatTo16BitPCM(view, 44, samples);
  return buffer;
}

function floatTo16BitPCM(output, offset, input) {
  for (let i = 0; i < input.length; i++, offset += 2) {
    let s = Math.max(-1, Math.min(1, input[i]));
    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
}

function writeString(view, offset, string) {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}
</script>

</body>
</html>