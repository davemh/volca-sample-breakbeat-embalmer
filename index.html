<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Volca Sample Breakbeat Embalmer</title>
<style>
body {
  background: #111;
  font-family: 'Verdana', sans-serif;
  color: #eee;
  display: flex;
  justify-content: center;
  padding: 30px;
}

.volca-panel {
  width: 500px;
  background: linear-gradient(#222, #111);
  border: 4px solid #555;
  border-radius: 15px;
  box-shadow: 0 0 20px #000;
  padding: 20px;
  background-image: 
    linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
  background-size: 10px 10px;
}

h1 {
  font-family: 'Courier New', monospace;
  color: #f5d76e;
  text-align: center;
  margin-bottom: 20px;
  text-shadow: 0 0 10px #f5d76e;
}

.controls {
  display: flex;
  flex-direction: column;
  gap: 15px;
  margin-bottom: 20px;
}

.control-group {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.control-group label {
  font-size: 14px;
  color: #f5d76e;
}

input[type=file] {
  color: #fff;
}

.readout {
  font-weight: bold;
  color: #0f0;
}

.buttons {
  display: flex;
  justify-content: center;
  margin-top: 20px;
}

button {
  background: linear-gradient(#333, #111);
  color: #fff;
  border-radius: 6px;
  border: 2px solid #555;
  padding: 10px 20px;
  cursor: pointer;
  font-weight: bold;
  box-shadow: 0 3px #000;
  transition: 0.1s;
}

button:hover {
  background: linear-gradient(#444, #222);
}

button:active {
  transform: translateY(2px);
  box-shadow: 0 1px #000;
}
</style>
</head>
<body>

<div class="volca-panel">
  <h1>Volca Sample Breakbeat Embalmer</h1>

  <div class="controls">
    <div class="control-group">
      <label>Select Audio File:</label>
      <input type="file" id="fileInput" accept="audio/*">
    </div>
    <div class="control-group">
      <label>Original Length (samples):</label>
      <span class="readout" id="origLength">--</span>
    </div>
    <div class="control-group">
      <label>Silence To Be Added (samples):</label>
      <span class="readout" id="silenceLength">--</span>
    </div>
  </div>

  <div class="buttons">
    <button id="processBtn">Export WAV</button>
  </div>
</div>

<script>
const fileInput = document.getElementById('fileInput');
const processBtn = document.getElementById('processBtn');
const origLengthEl = document.getElementById('origLength');
const silenceLengthEl = document.getElementById('silenceLength');

let currentBuffer = null;

async function decodeAudioFile(file) {
  const arrayBuffer = await file.arrayBuffer();
  const audioCtx = new AudioContext();
  return audioCtx.decodeAudioData(arrayBuffer);
}

fileInput.addEventListener('change', async () => {
  const file = fileInput.files[0];
  if (!file) return;
  const buffer = await decodeAudioFile(file);
  currentBuffer = buffer;
  const length = buffer.length;
  const silenceLength = Math.floor(length * 0.11111);
  origLengthEl.textContent = length.toLocaleString();
  silenceLengthEl.textContent = silenceLength.toLocaleString();
});

processBtn.addEventListener('click', () => {
  if (!currentBuffer) {
    alert("Please select a file first.");
    return;
  }

  const numChannels = currentBuffer.numberOfChannels;
  const sampleRate = currentBuffer.sampleRate;
  const length = currentBuffer.length;
  const silenceLength = Math.floor(length * 0.11111);
  const newLength = length + silenceLength;

  const newBuffer = new AudioBuffer({
    length: newLength,
    numberOfChannels: numChannels,
    sampleRate: sampleRate
  });

  // Copy original audio
  for (let ch = 0; ch < numChannels; ch++) {
    const oldData = currentBuffer.getChannelData(ch);
    const newData = newBuffer.getChannelData(ch);
    newData.set(oldData, 0);
    // rest remains silence
  }

  const wavArrayBuffer = audioBufferToWav(newBuffer);
  const blob = new Blob([wavArrayBuffer], { type: "audio/wav" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "processed.wav";
  a.click();
});

// ==== WAV ENCODER (unchanged) ====
function audioBufferToWav(buffer) {
  const numChannels = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const format = 1; // PCM
  const bitDepth = 16;

  let result;
  if (numChannels === 2) {
    result = interleave(buffer.getChannelData(0), buffer.getChannelData(1));
  } else {
    result = buffer.getChannelData(0);
  }

  return encodeWav(result, numChannels, sampleRate, format, bitDepth);
}

function interleave(left, right) {
  const length = left.length + right.length;
  const result = new Float32Array(length);
  let index = 0, inputIndex = 0;
  while (index < length) {
    result[index++] = left[inputIndex];
    result[index++] = right[inputIndex];
    inputIndex++;
  }
  return result;
}

function encodeWav(samples, numChannels, sampleRate, format, bitDepth) {
  const bytesPerSample = bitDepth / 8;
  const blockAlign = numChannels * bytesPerSample;
  const buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
  const view = new DataView(buffer);

  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + samples.length * bytesPerSample, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, format, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * blockAlign, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitDepth, true);
  writeString(view, 36, 'data');
  view.setUint32(40, samples.length * bytesPerSample, true);

  floatTo16BitPCM(view, 44, samples);
  return buffer;
}

function floatTo16BitPCM(output, offset, input) {
  for (let i = 0; i < input.length; i++, offset += 2) {
    let s = Math.max(-1, Math.min(1, input[i]));
    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
}

function writeString(view, offset, string) {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}
</script>

</body>
</html>
